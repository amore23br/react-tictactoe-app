<< 클래스형 컴포넌트 >>

1. props를 통해 컴포넌트 간 데이터 전달하기
- 부모 컴포넌트 => 자식 컴포넌트로 데이터 전달 
- 읽기 전용으로 자식 컴포넌트는 변경되지 않음 → 즉, 부모에서 값이 바껴야 자식도 바뀐다

2. State
- 무언가를 기억하기 위해 사용
- 해당 컴포넌트 내부에서 데이터를 전달하기 위해 사용
- 데이터가 변할 때 화면을 다시 렌더링 해주기 위해서는 React State 사용필요!

★ 결국!! 값이 바껴야한다? state / 그냥 값만 내려주면 된다? props

3. Constructor (생성자)
- 인스턴스화된 객체에서 다른 메서드를 호출하기 전에 수행해야 하는 사용자 지정 초기화를 제공할 수 있다. 
  즉, 초기설정

4. Super
- 자식 클래스 내에서 부모클래스의 '생성자' 또는 '메소드'를 호출할때 사용
- 자바스크립트 문법 
  super([arguments]); //부모 생성자 호출
  super.functionOnParent([arguments]);

- super 다음에 this 를 써줘야함 → this가 먼저 선언되면 error 발생
- super 키워드로 값을 할당 
- Constructor안에 this 키워드를 쓰고 싶으면 super 를 써줘야함!! 


========================================================================
< 리액트의 불변성 >
원시타입(Boolean, String, Number, null, undefined, Symbol)
ㄴ 고정된 크기로 Call Stack 메모리에 저장, 실제 데이터가 변수에 할당 

참조타입(Object, Array)
ㄴ 데이터 크기 미정
ㄴ Call Stack 메모리에 저장 > 데이터의 값이 heap에 저장되며 변수에 heap메모리의 주소값이 할당
ㄴ 불변성 유지 안되기때문에 신경쓸것!!
ㄴ 원본 데이터 변경 메소드 => splice, push


<컴포넌트>
클래스형 컴포넌트 : 더 많은 기능 제공, 긴 코드양, 복잡한 코드, 더딘 성능
함수형 컴포넌트 : 적은 기능 제공, 짧은 코드 양, 단순한 코드, 빠른 성능 

========================================================================
JSK Key 속성 
- 요소의 리스트를 나열할 때 Key를 넣어줘야함 
- 리액트가 변경, 추가 또는 제거된 항목을 식별하는데 도움이 된다 
- 리액트는 가상 돔을 이용해 바뀐 부분만 실제 돔에 적용 -> key를 이용해 식별 
- key는 유니크한 값이 필요 (index는 비추천) -> 순차적으로 리스트에 추가되지 않고 리스트 사이에 추가되거나 제거되면 리스트의 인덱스 번호도 바뀜 (변경된일이없으면 index사용가능)
- 